<%= render("features_navigation") %>

<section>
  <h2>Methods</h2>
  <code>
<span class="comment">// Basic method definition</span>
<span class="keyword">method</span> <span class="function">method_one</span>()
{
}

<span class="comment">// Returned values are implied, so a method that doesn't</span>
<span class="comment">// return anything actually does return nil</span>
<span class="keyword">method</span> <span class="function">method_two</span>()
{
    <span class="keyword">return</span> <span class="keyword">nil</span>
}

<span class="comment">// Arguments also need not specify type</span>
<span class="keyword">method</span> <span class="function">method_three</span>(a)
{
    <span class="keyword">return</span> <span class="keyword">a</span>
}

<span class="comment">// But, a type can be supplied, which permits</span>
<span class="comment">// extra compiler checks</span>
<span class="keyword">method</span> <span class="function">method_four</span>(<span class="entity">Object</span> a)
{
    <span class="keyword">return</span> <span class="keyword">a</span>
}

<span class="comment">// Types can also be provided for a return value</span>
<span class="keyword">method</span> <span class="function">method_five</span>(<span class="entity">Object</span>; <span class="entity">Object</span> a)
{
    <span class="keyword">return</span> <span class="keyword">a</span>
}

<span class="comment">// Labels are only optional for the first argument, but are required for all others</span>
<span class="keyword">method</span> <span class="function">method_six</span>(<span class="entity">Number</span>; <span class="entity">Number</span> a, <span class="entity">Number</span> <span class="function">with_number:</span>b)
{
    <span class="keyword">return</span> a.<span class="function">value</span> + b
}

<span class="comment">// Without types, that method looks like this</span>
<span class="keyword">method</span> <span class="function">method_seven</span>(a, <span class="function">with_number:</span>b)
{
    <span class="keyword">return</span> a.<span class="function">value</span> + b
}


<span class="comment">// the body method allows you to control how overriding will work</span>
<span class="keyword">method</span> <span class="function">method_eight</span>(<span class="entity">Integer</span>; <span class="entity">Integer</span> input)
{
    <span class="entity">Integer</span> x
    
    <span class="comment">// subclassers can only change the body block</span>
    x = <span class="keyword">body</span>(input) |<span class="entity">Integer</span>; <span class="entity">Integer</span> body_input|
    {
        <span class="comment">// this is the default implementation </span>
        <span class="keyword">return</span> body_input + <span class="literal">1</span>
    }
    
    <span class="keyword">return</span> x + <span class="literal">1</span>
}

<span class="comment">// You can define methods on the class object itself by pre-pending</span>
<span class="comment">// "class" to a method, property, indexer or operator</span>
<span class="keyword">class method</span> <span class="function">a_class_method</span>()
{
}

<span class="comment">// Accessors can be called without parenthesis </span>
<span class="keyword">property</span> <span class="function">my_property</span>(<span class="entity">Integer</span>; <span class="entity">Integer</span> value)
{
    <span class="keyword">get</span>
    {
        <span class="keyword">return</span> x
    }
    <span class="keyword">set</span>
    {
        x = value
    }
}

<span class="comment">// The indexer keyword denotes a method that uses the square bracket for calling. </span>
<span class="comment">// The name can be "self" for "object[6]", or a label for "object.label[5]"</span>
<span class="keyword">indexer</span> <span class="keyword">self</span>[<span class="entity">Integer</span> i](<span class="entity">Integer</span>; <span class="entity">Integer</span> value)</span>
{
    <span class="keyword">get</span>
    {
        <span class="keyword">return</span> i
    }
    <span class="keyword">set</span>
    {
        x = value
    }
}

<span class="comment">// There are five operators for supporting the arithmetic operators '+', </span>
<span class="comment">// '-', '/', '*' and '%'</span>
<span class="keyword">operator</span> <span class="keyword">+</span>(<span class="entity">Entity</span> other)
{
    <span class="keyword">self</span>.<span class="function">value</span> += other.<span class="function">value</span>
    
    <span class="keyword">return</span> <span class="keyword">self</span>.<span class="function">value</span>
}

<span class="keyword">operator</span> <span class="keyword">-</span>(<span class="entity">Entity</span> other)
<span class="keyword">operator</span> <span class="keyword">*</span>(<span class="entity">Entity</span> other)
<span class="keyword">operator</span> <span class="keyword">/</span>(<span class="entity">Entity</span> other)
<span class="keyword">operator</span> <span class="keyword">%</span>(<span class="entity">Entity</span> other)

<span class="comment">// returns (-1,0,1,other) to support &lt;, &lt;=, ==, &gt;=, &gt;, and != </span>
<span class="keyword">operator</span> <span class="keyword">&lt;=&gt;</span>(<span class="entity">Entity</span> other)
{
    <span class="keyword">return</span> <span class="keyword">self</span>.<span class="function">value</span>.<span class="function">compare</span>(other.<span class="function">value</span>)
}

<span class="comment">// case-compare for switch statements </span>
<span class="keyword">operator</span> <span class="keyword">===</span>(<span class="entity">Entity</span> other)
  </code>
</section>
