<%= render("features_navigation") %>

<section>
  <h2>Methods</h2>
  <code>
<span class="comment">// Methods are similar to functions, but are associated to an interface</span>
<span class="keyword">method</span> <span class="function">a_method</span>(<span class="entity">Integer</span>; <span class="entity">Pointer</span> a, <span class="entity">Integer</span> <span class="function">with_integer:</span>b)
{
    <span class="keyword">return</span> a.<span class="function">value</span> + b
}

<span class="comment">// the body function allows you to control how overriding will work</span>
<span class="keyword">method</span> <span class="function">a_method</span>(<span class="entity">Integer</span>; <span class="entity">Integer</span> input)
{
    <span class="entity">Integer</span> x
    
    <span class="comment">// subclassers can only change the body block</span>
    x = <span class="keyword">body</span>(input) |<span class="entity">Integer</span>; <span class="entity">Integer</span> body_input|
    {
        <span class="comment">// this is the default implementation </span>
        <span class="keyword">return</span> body_input + <span class="literal">1</span>
    }
    
    <span class="keyword">return</span> x + <span class="literal">1</span>
}

<span class="comment">// Accessors can be called without parenthesis </span>
<span class="keyword">property</span> <span class="function">my_property</span>(<span class="entity">Integer</span>; <span class="entity">Integer</span> value)
{
    <span class="keyword">get</span>
    {
        <span class="keyword">return</span> x
    }
    <span class="keyword">set</span>
    {
        x = value
    }
}

<span class="comment">// The indexer keyword denotes a method that uses the square bracket for calling. </span>
<span class="comment">// The name can be "self" for "object[6]", or a label for "object.label[5]"</span>
<span class="keyword">indexer</span> <span class="keyword">self</span>[<span class="entity">Integer</span> i](<span class="entity">Integer</span>; <span class="entity">Integer</span> value)</span>
{
    <span class="keyword">get</span>
    {
        <span class="keyword">return</span> i
    }
    <span class="keyword">set</span>
    {
        x = value
    }
}

<span class="comment">// There are five operators for supporting the arithmetic operators '+', </span>
<span class="comment">// '-', '/', '*' and '%'</span>
<span class="keyword">operator</span> <span class="keyword">+</span>(<span class="entity">Entity</span> other)
{
    <span class="keyword">self</span>.<span class="function">value</span> += other.<span class="function">value</span>
    
    <span class="keyword">return</span> <span class="keyword">self</span>.<span class="function">value</span>
}

<span class="keyword">operator</span> <span class="keyword">-</span>(<span class="entity">Entity</span> other)
<span class="keyword">operator</span> <span class="keyword">*</span>(<span class="entity">Entity</span> other)
<span class="keyword">operator</span> <span class="keyword">/</span>(<span class="entity">Entity</span> other)
<span class="keyword">operator</span> <span class="keyword">%</span>(<span class="entity">Entity</span> other)

<span class="comment">// returns (-1,0,1,other) to support &lt;, &lt;=, ==, &gt;=, &gt;, and != </span>
<span class="keyword">operator</span> <span class="keyword">&lt;=&gt;</span>(<span class="entity">Entity</span> other)
{
    <span class="keyword">return</span> <span class="keyword">self</span>.<span class="function">value</span>.<span class="function">compare</span>(other.<span class="function">value</span>)
}

<span class="comment">// case-compare for switch statements </span>
<span class="keyword">operator</span> <span class="keyword">===</span>(<span class="entity">Entity</span> other)
  </code>
</section>
