<%= render("features_navigation") %>

<section>
  <h2>Object Life Cycle</h2>
  <code>
<span class="comment">// Classes all follow a simple retain counting mechanism, but these details</span>
<span class="comment">// are hidden from the developer.  The result ends up looking a lot like a</span>
<span class="comment">// garbage-collected environment</span>
<span class="keyword">method</span> <span class="function">simple_example</span>()
{
    <span class="entity">MyObject</span> obj
    
    <span class="comment">// Retain count of +1</span>
    obj = <span class="entity">MyObject</span>.<span class="function">new</span>()
    
    <span class="comment">// At this point, obj will fall out of scope, so its</span>
    <span class="comment">// retain count is decremented.  This results in the</span>
    <span class="comment">// count getting to zero, which causes a deallocation</span>
}

<span class="comment">// Consider this next example.  A newly allocated object is</span>
<span class="comment">// returned.  Here, the object is not yet out of scope, so its</span>
<span class="comment">// retain count is not modified.</span>
<span class="keyword">method</span> <span class="function">returns_new</span>()
{
    <span class="keyword">return</span> <span class="entity">MyObject</span>.<span class="function">new</span>()
}

<span class="comment">// The semantics of this system is a lot like boost::shared_ptr in C++.</span>
  </code>
</section>
