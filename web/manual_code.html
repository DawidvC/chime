<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>Code</title>
        <style>
            #banner       { margin: 10px; }
            
            pre           { margin: 5px; }
            
            .codeblock    { margin: 10px; padding: 4px; border: 2px solid #999999; color: #fff; background-color: #000000; }
            
            .plain        { color: #ffffff; }
            .attribute    { color: #9cb4db; }
            .keyword      { color: #fce700; }
            .entity       { color: #ff8f00; }
            .variable     { color: #00fee0; }
            .function     { color: #9cb4db; }
            .comment      { color: #bcbcbc; }
            .superclass   { color: #ff8f00; font-style: italic;}
            .literal      { color: #d5ff00; }
            .constant     { color: #d5ff00; }
            .string       { color: #46dd27; }
            .preprocessor { color: #90a1bb; }
        </style>
    </head>
    <body id="index" class="home">
        <header id="banner" class="body">
            Chime
        </header>
        <section id="intro" class="body">
            The idea behind Chime is to provide the following features:
            <ul>
                <li>Full support for pointers, value types and structures</li>
                <li>An object-oriented model for low-level operations</li>
                <li>High-level object-oriented constructs</li>
                <li>Meta-data for both compiler hinting and runtime introspection</li>
                <li>Static dispatch when needed and dynamic dispatch otherwise</li>
                <li>A consistent syntax for both high- and low-level operations</li>
            </ul>
        </section>
        <section id="content" class="body">
            <h2>Structures</h2>
            <div class="codeblock">
                <code>
                    <pre>
<span class="comment">// Starting off, we have a tag.  This is some metadata that is passed along to the compiler </span>
<span class="comment">// and the runtime as well.</span>
<span class="attribute">&lt;<span class="keyword">@arch</span>:<span class="plain">i386</span>, <span class="keyword">@align</span>:<span class="plain">packed</span>&gt;</span>
<span class="keyword">structure</span> <span class="entity">MyStructure</span>
{
    <span class="comment">// Structures are made up of built-in Types </span>
    
    <span class="entity">Integer</span>     default_32_bit_size
    <span class="entity">Integer</span><span class="attribute">&lt;<span class="literal">3</span>&gt;</span>  three_bit_integer
    
    <span class="entity">Integer</span><span class="attribute">[<span class="literal">5</span>]</span>    array_of_five_integers
    <span class="entity">Integer</span><span class="attribute">&lt;<span class="literal">8</span>&gt;</span><span class="attribute">[<span class="literal">5</span>]</span> array_of_five_8_bit_integers
    
    <span class="entity">Natural</span><span class="attribute">&lt;<span class="literal">16</span>&gt;</span> 16_bit_unsigned_integer
    
    <span class="entity">Float</span><span class="attribute">&lt;<span class="literal">32</span>&gt;</span>   32_bit_floating_point_number
}

<span class="comment">// Once defined, structures are Value types themselves</span>
<span class="keyword">structure</span> <span class="entity">MyNewStructure</span>
{
    <span class="entity">MyStructure</span><span class="attribute">[<span class="literal">2</span>]</span> two_structures
}</pre>
                </code>
            </div>
            
            <h2>Flow Control</h2>
            <div class="codeblock">
                <code>
                    <pre>
<span class="comment">// for loops </span>
<span class="keyword">for</span> (i = <span class="literal">0</span>; i &lt; <span class="literal">10</span>; i++)
{
    <span class="keyword">break</span> <span class="comment">// exits the immediately contained scope</span>
}

<span class="comment">// while loop</span>
<span class="keyword">while</span> (<span class="keyword">true</span> <span class="keyword">or</span> <span class="keyword">false</span>)
{
    <span class="keyword">break</span> <span class="comment">// don't spin forever</span>
}

<span class="comment">// until loop - equivalent to "while (not xyz)"</span>
<span class="keyword">until</span> (<span class="keyword">false</span>)
{
    <span class="keyword">continue</span> <span class="comment">// kills this loop iteration</span>
}

<span class="comment">// loop, but check condition at end instead of start</span>
<span class="keyword">do</span>
{
    <span class="keyword">continue</span> <span class="comment">// kills this loop iteration</span>
} <span class="keyword">until</span> (<span class="keyword">false</span>)

<span class="comment">// if and else</span>
<span class="comment">// 'false', '0', and 'nil' evaluate to logical false</span>
<span class="keyword">if</span> (<span class="keyword">true</span> <span class="keyword">and</span> <span class="keyword">false</span>)
    <span class="function">something</span>()
<span class="keyword">else</span>
{
    <span class="function">something_else</span>()
}

<span class="comment">// unless and tailing conditions</span>
x = <span class="literal">5</span> <span class="keyword">unless</span> x > <span class="literal">10</span>

<span class="comment">// unless and tailing conditions</span>

<span class="comment">// switch  makes use of the "case_compare" method</span>
<span class="comment">// operator.  A case statement can be an expression.</span>
<span class="comment">// Cases do not fall through.  That's just crazy.</span>
<span class="keyword">switch</span> (<span class="literal">value</span>)
{
    <span class="keyword">case</span> <span class="literal">10</span>
        <span class="function">something</span>()
    <span class="keyword">case</span> <span class="string">"abc"</span>
        <span class="function">something_else</span>()
    <span class="keyword">case</span> (<span class="literal">5</span> + <span class="literal">2</span>)
        <span class="function">something</span>()
        <span class="function">something_else</span>()
    <span class="keyword">else</span>
        <span class="function">no_matches</span>()
}</pre>
                </code>
            </div>
            
            <h2>Functions</h2>
            <div class="codeblock">
                <code>
                    <pre>
<span class="comment">// This is the simplest function definition.</span>
<span class="keyword">function</span> <span class="function">function_one</span>()
{
}

<span class="comment">// Here's a function that takes one pointer as an argument</span>
<span class="keyword">function</span> <span class="function">function_two</span>(<span class="entity">Pointer</span> a)
{
}

<span class="comment">// Pointers are the default type, so if you omit the type Pointer</span>
<span class="comment">// is used.  Return values work the same way.  If there is no return </span>
<span class="comment">// statement, nil is implied</span>
<span class="keyword">function</span> <span class="function">function_three</span>(a)
{
    <span class="keyword">return</span> a
}

<span class="comment">// Explicit types for returns are allowed</span>
<span class="keyword">function</span> <span class="function">function_four</span>(<span class="entity">Void</span>;a)
{
    <span class="comment">// return statement not allowed in this function</span>
}

<span class="comment">// Labels are only optional for the first argument, but are required for all others</span>
<span class="keyword">function</span> <span class="function">function_five</span>(<span class="entity">Pointer</span> a, <span class="entity">Integer</span> <span class="function">with_integer:</span>b)
{
}

<span class="comment">// Return types are specified first, followed by a semi-colon</span>
<span class="keyword">function</span> <span class="function">function_six</span>(<span class="entity">Integer</span>; <span class="entity">Pointer</span> a, <span class="entity">Integer</span> <span class="function">with_integer:</span>b)
{
    <span class="keyword">return</span> a.<span class="function">value</span> + b
}
                    </pre>
                </code>
            </div>
            
            <h2>Blocks</h2>
            <div class="codeblock">
                <code>
                    <pre>
<span class="comment">// Here's a function that accepts a function as one of its arguments</span>
<span class="keyword">function</span> <span class="function">use_block</span>(<span class="entity">Integer</span>; <span class="entity">Function</span>(<span class="entity">Integer</span>;) block_argument)
{
    <span class="keyword">return</span> <span class="function">block_argument</span>() * <span class="literal">2</span>
}

<span class="keyword">function</span> <span class="function">empty_block</span>(<span class="entity">Integer</span>; <span class="entity">Function</span> block_argument)
{
    <span class="comment">// Blocks follow the same rules as functions.  They return a Pointer</span>
    <span class="comment">// unless otherwise specified, and they can implicitly return nil</span>
    <span class="function">block_argument</span>()
}

<span class="comment">// These are some examples of anonymous functions/blocks</span>
<span class="keyword">function</span> <span class="function">more_blocks</span>(<span class="entity">Integer</span> x)
{
    <span class="entity">Integer</span> value
    
    <span class="comment">// pass in an anonymous function</span>
    value = <span class="function">use_block</span>({ |<span class="entity">Integer</span>;| <span class="keyword">return</span> <span class="literal">5</span> })
    
    <span class="comment">// this notation is equivalent for the <strong>last</strong> argument only</span>
    value = <span class="function">use_block</span>() { |<span class="entity">Integer</span>;|
        <span class="keyword">return</span> <span class="literal">5</span>
    }
    
    <span class="comment">// blocks that have no return or arguments do not require the pipes.</span>
    <span class="comment">// note that value has been 'closed over'</span>
    <span class="function">empty_block</span>({ <span class="function">do_something</span>(value) })
    
    <span class="comment">// you can assign to local variables, but this</span>
    <span class="comment">// just passing in the address of the variable.  Depending</span>
    <span class="comment">// on when the block is used, this could be bad</span>
    <span class="function">empty_block</span>() {
        value = <span class="function">do_something</span>(0)
    }
}

<span class="comment">// Functions are just another type</span>
<span class="keyword">function</span> <span class="function">function_type</span>()
{
    <span class="entity">Function</span>(<span class="entity">Integer</span>; <span class="entity">Integer</span>, <span class="entity">Integer</span> <span class="function">and:</span>) sum
    
    sum = { |<span class="entity">Integer</span>; <span class="entity">Integer</span> x, <span class="entity">Integer</span> <span class="function">and:</span>y|
      <span class="keyword">return</span> x + y
    }
    
    <span class="function">sum</span>(<span class="literal">1</span>, <span class="function">and:</span><span class="literal">1</span>)
}</pre>
                </code>
            </div>
            
            <h2>Methods</h2>
            <div class="codeblock">
                <code>
                    <pre>
<span class="comment">// Methods are similar to functions, but are associated to an interface</span>
<span class="keyword">method</span> <span class="function">a_method</span>(<span class="entity">Integer</span>; <span class="entity">Pointer</span> a, <span class="entity">Integer</span> <span class="function">with_integer:</span>b)
{
    <span class="keyword">return</span> a.<span class="function">value</span> + b
}

<span class="comment">// the body pseudo-method let you control how a subclass's</span>
<span class="comment">// overridden method will behave</span>
<span class="keyword">method</span> <span class="function">a_method</span>(<span class="entity">Integer</span>; <span class="entity">Integer</span> input)
{
    <span class="entity">Integer</span> x
  
    x = <span class="keyword">body</span>(input) { |<span class="entity">Integer</span>; <span class="entity">Integer</span> body_input|
      <span class="comment">// this is the default implementation, and is the </span>
      <span class="comment">// only part of this method that can be overridden </span>
      <span class="keyword">return</span> body_input</span>
    }
    
    <span class="keyword">return</span> x + <span class="literal">1</span>
}

<span class="comment">// Accessors can be called without parenthesis </span>
<span class="keyword">property</span> <span class="function">my_property</span>(<span class="entity">Integer</span>;<span class="entity">Integer</span> value)
{
    <span class="keyword">get</span>
    {
        <span class="keyword">return</span> x
    }
    <span class="keyword">set</span>
    {
        x = value
    }
}

<span class="comment">// The indexer keyword denotes a method that uses the square bracket for calling. </span>
<span class="comment">// The name can be "self" for "object[6]", or a label for "object.label[5]"</span>
<span class="keyword">indexer</span> <span class="keyword">self</span>[<span class="entity">Integer</span> i](<span class="entity">Integer</span>; <span class="entity">Integer</span> value)</span>
{
    <span class="keyword">get</span>
    {
        <span class="keyword">return</span> i
    }
    <span class="keyword">set</span>
    {
        x = value
    }
}

<span class="comment">// There are five operators for supporting the arithmetic operators '+', </span>
<span class="comment">// '-', '/', '*' and '%'</span>
<span class="keyword">operator</span> <span class="keyword">+</span>(<span class="entity">Entity</span> other)
{
    <span class="keyword">self</span>.<span class="function">value</span> += other.<span class="function">value</span>
    
    <span class="keyword">return</span> <span class="keyword">self</span>.<span class="function">value</span>
}

<span class="keyword">operator</span> <span class="keyword">-</span>(<span class="entity">Entity</span> other)
<span class="keyword">operator</span> <span class="keyword">*</span>(<span class="entity">Entity</span> other)
<span class="keyword">operator</span> <span class="keyword">/</span>(<span class="entity">Entity</span> other)
<span class="keyword">operator</span> <span class="keyword">%</span>(<span class="entity">Entity</span> other)

<span class="comment">// returns (-1,0,1,other) to support &lt;, &lt;=, ==, &gt;=, &gt;, and != </span>
<span class="keyword">operator</span> <span class="keyword">&lt;=&gt;</span>(<span class="entity">Entity</span> other)
{
    <span class="keyword">return</span> <span class="keyword">self</span>.<span class="function">value</span>.<span class="function">compare</span>(other.<span class="function">value</span>)
}

<span class="comment">// case-compare for switch statements </span>
<span class="keyword">operator</span> <span class="keyword">===</span>(<span class="entity">Entity</span> other)</pre>
                </code>
            </div>
            
            <h2>Interfaces</h2>
            <div class="codeblock">
                <code>
                        <pre>
<span class="comment">// An interface is a externally-accessible definition of methods</span>
<span class="comment">// that a class implements.  Inheritance is also defined, but only via</span>
<span class="comment">// the other interfaces that the class implements.</span>
<span class="comment">// </span>
<span class="comment">// An interface does not define any of the class's internal structure.</span>
<span class="comment">// By extension, it is not possible to access a super-class's instance variables.</span>
<span class="comment">// </span>
<span class="comment">// A subclasser need only know about these methods and those defined by</span>
<span class="comment">// the Object interface</span>
<span class="keyword">interface</span> <span class="entity">Array</span> : <span class="superclass">Object</span>
{
    <span class="keyword">property</span> <span class="function">length</span>(<span class="entity">Natural</span>;)
    
    <span class="keyword">indexer</span> <span class="keyword">self</span>[<span class="entity">Natural</span> index](<span class="entity">Object</span>; <span class="entity">Object</span>)
    
    <span class="keyword">method</span> <span class="function">each</span>(<span class="entity">Function</span>(<span class="entity">Object</span>) block)
}</pre>
                </code>
            </div>
            
            <h2>Pointers and Pseudo-Methods</h2>
            <div class="codeblock">
                <code>
                    <pre>
<span class="comment">// Before we get to implementations, let's take a look at Pointers.</span>
<span class="comment">// In Chime, a pointer is a Pseudo-Object.  That is, it's a value type</span>
<span class="comment">// that acts a lot like a true object to the programmer</span>
<span class="keyword">interface</span> <span class="entity">Pointer</span> : <span class="superclass">ValueType</span>
{
    <span class="comment">// This is the address this Pointer object references</span>
    <span class="keyword">property</span> <span class="function">value</span>(<span class="entity">Natural</span>; <span class="entity">Natural</span>)
    
    <span class="comment">// The Type this pointer points to.  Setting this is</span>
    <span class="comment">// required if you want to do pointer arithmetic.</span>
    <span class="keyword">property</span> <span class="function">reference</span>(<span class="entity">Type</span>; <span class="entity">Type</span>)
    
    <span class="comment">// This pseudo-method dereferences a pointer as the specified type.</span>
    <span class="comment">// The empty return value means there is a return, but it is</span>
    <span class="comment">// determined at run time (actually compile-time)</span>
    <span class="keyword">method</span> <span class="function">deref_as</span>(<span class="entity">Type</span>; <span class="entity">Type</span>)
    
    <span class="comment">// C-style offset-then-deref</span>
    <span class="keyword">indexer</span> <span class="keyword">self</span>[<span class="entity">Integer</span> index](<span class="entity">Type</span>;)</span>
    
    <span class="comment">// If 'reference' is set, no need to specify the type</span>
    <span class="keyword">method</span> <span class="function">deref</span>(<span class="entity">Type</span>;)
}

<span class="comment">// Here is some example usage</span>
<span class="entity">Pointer</span> p
<span class="entity">Integer</span> int

<span class="comment">// Imagine there is a MyStructure at 0x1234</span>
p.<span class="function">value</span> = <span class="literal">0x1234</span>

p.<span class="function">deref_as</span>(<span class="entity">MyStructure</span>).<span class="function">three_bit_integer</span>++

int = <span class="literal">0x1234</span>

<span class="comment">// 'to_pointer' is another pseudo-method of Integer and</span>
<span class="comment">// Natural that returns a Pointer representation.</span>
<span class="comment">// The value of p is now whatever was in int (0x1234)</span>
p = int.<span class="function">to_pointer</span>()

<span class="comment">// 'address' is the equivalent of '&amp;' in C and works</span>
<span class="comment">// for all value types</span>
p = int.<span class="function">address</span>

p.<span class="function">deref_as</span>(<span class="entity">Integer</span>).<span class="function">to_pointer</span>().<span class="function">deref_as</span>(<span class="entity">MyStructure</span>)
                    </pre>
                </code>
            </div>
            
            <h2>Implementations</h2>
            <div class="codeblock">
                <code>
                    <pre>
<span class="comment">// An implementation is an internal definition of a class </span>
<span class="comment">// structure and behavior.  Here, the actual super-class is </span>
<span class="comment">// specified.  This definition does affect the class's internal</span>
<span class="comment">// structure.</span>
<span class="keyword">implementation</span> <span class="entity">Array</span> : <span class="superclass">Object</span>
{
    <span class="comment">// Structure is defined by instance variables (and the superclass)</span>
    <span class="entity">Pointer</span><span class="attribute">[<span class="literal">10</span>]</span> <span class="variable">objects</span>
    
    <span class="comment">// Behavior is defined by methods</span>
    
    <span class="keyword">property</span> <span class="function">length</span>(<span class="entity">Natural</span>;)
    {
        <span class="keyword">get</span>
        {
            <span class="keyword">return</span> <span class="literal">10</span>
        }
    }
    
    <span class="comment">// Here's an indexer implementation that highlights the use</span>
    <span class="comment">// of pointers and pointer arithmetic.</span>
    <span class="keyword">indexer</span> <span class="keyword">self</span>[<span class="entity">Natural</span> index](<span class="entity">Object</span>; <span class="entity">Object</span> value)
    {
        <span class="keyword">get</span>
        {
            <span class="keyword">return</span> <span class="keyword">nil</span> <span class="keyword">if</span> index &gt;= <span class="keyword">self</span>.<span class="function">length</span>
            
            <span class="comment">// Notice that no typecasting is required on the return</span>
            <span class="comment">// because all Reference types are considered equivalent</span>
            <span class="keyword">return</span> <span class="variable">objects</span>[index]
        }
        <span class="keyword">set</span>
        {
            <span class="keyword">return</span> <span class="keyword">if</span> index &gt;= <span class="keyword">self</span>.<span class="function">length</span>

            <span class="variable">objects</span>[index] = value
        }
    }
    
    <span class="keyword">method</span> <span class="function">each</span>(<span class="entity">Function</span>(<span class="entity">Object</span>) block)
    {
        <span class="entity">Natural</span> i
        
        <span class="keyword">for</span> (i = <span class="literal">0</span>; i &lt; <span class="literal">10</span>; i++)
        {
            <span class="function">block</span>(<span class="keyword">self</span>[i])
        }
        
        <span class="comment">// or, with a fancier block pseudo-method on Integer</span>
        <span class="literal">10</span>.<span class="function">times</span>() { |<span class="entity">Void</span>; <span class="entity">Natural</span> j|
            <span class="function">block</span>(<span class="keyword">self</span>[j])
        }
    }
}</pre>
                </code>
            </div>
            
            <h2>Dispatch</h2>
            <div class="codeblock">
                <code>
                    <pre>
<span class="comment">// The term dispatch refers to determining the actual code to execute</span>
<span class="comment">// based on the type and method invoked.  Chime has a few simple rules.</span>

<span class="comment">// Functions that aren't associated with a type are always</span>
<span class="comment">// dispatched statically, based only on scope</span>
<span class="function">sum</span>(1, <span class="function">and:</span>1)

<span class="comment">// Pseudo-methods are a little special.  In many cases, they</span>
<span class="comment">// aren't even functions at all.  They are really just </span>
<span class="comment">// compiler operations, so they are "even more" static than functions.</span>
<span class="entity">Integer</span> i

i.<span class="function">address</span>

<span class="comment">// Methods are always dispatched dynamically.  There</span>
<span class="comment">// will not be a compiler warning, but there might be</span>
<span class="comment">// a runtime error if this object and all its superclasses</span>
<span class="comment">// do not implement the method</span>
<span class="entity">MyObject</span> obj

obj = <span class="entity">MyObject</span>.<span class="keyword">new</span>()

obj.<span class="function">some_method</span>(<span class="literal">7</span>)
                    </pre>
                </code>
            </div>
            
            <h2>Constants</h2>
            <div class="codeblock">
                <code>
                    <pre>
<span class="comment">// You can define numerical/value-type constants using</span>
<span class="comment">// a scripting-language style.</span>
<span class="entity">Integer</span> <span class="constant">MY_CONSTANT</span> = <span class="literal">7</span>

<span class="comment">// Strings are slightly special, this one is an object, and</span>
<span class="comment">// is allowed to contain unicode characters.</span>
<span class="entity">String</span> <span class="constant">MY_STRING</span> = <span class="string">"abc"</span>

<span class="comment">// This is just a pointer to ascii data</span>
<span class="entity">Pointer</span> <span class="constant">MY_C_STRING</span> = <span class="string">c"abc"</span></pre>
                </code>
            </div>
            
            <h2>Object Lifecycle</h2>
            <div class="codeblock">
                <code>
                    <pre>
<span class="comment">// Classes all follow a simple retain counting mechanism</span>
<span class="entity">MyObject</span> obj

<span class="comment">// Retain count of +1</span>
obj = <span class="entity">MyObject</span>.<span class="function">new</span>()

<span class="comment">// Retain count of +2</span>
obj.<span class="function">retain</span>()

<span class="comment">// Retain count of +1</span>
obj.<span class="function">release</span>()

<span class="comment">// Retain count of 0, deallocated</span>
obj.<span class="function">release</span>()

<span class="comment">// This introduces a problem with functions/methods that</span>
<span class="comment">// return values.  How does a caller (and the compiler) know</span>
<span class="comment">// that ownership is being transferred?</span>

<span class="keyword">function</span> <span class="function">new_object</span>(<span class="keyword">retained</span>;)
{
    <span class="keyword">return</span> <span class="entity">MyObject</span>.<span class="function">new</span>()
}

<span class="comment">// The compiler (and hopefully you) know that you</span>
<span class="comment">// own this return value</span>
obj = <span class="function">new_object</span>();
                    </pre>
                </code>
            </div>
            
            <h2>Exceptions</h2>
            <div class="codeblock">
                <code>
                    <pre>
<span class="comment">// try-catch-finally, just like you know them</span>
<span class="keyword">try</span>
{
    <span class="comment">// throw works a lot like return</span>
    <span class="keyword">throw</span> <span class="entity">RuntimeException</span>.<span class="function">new</span>(<span class="literal">"BOOM!"</span>)
}
<span class="keyword">catch</span>(<span class="entity">RuntimeException</span> e)
{
    <span class="comment">// catch a specific exception class</span>
}
<span class="keyword">catch</span>(e)
{
    <span class="comment">// catch everything else</span>
}
<span class="keyword">finally</span>
{
    <span class="comment">// called no matter what, unless exception bubbles to the top</span>
}</pre>
                </code>
            </div>
            
            <h2>Assembly</h2>
            <div class="codeblock">
                <code>
                    <pre>
<span class="preprocessor">assembly</span>
{
    <span class="comment">// crazy assembly goes here</span>
}</pre>
                </code>
            </div>
            
            <h2>Conditional Compilation</h2>
            <div class="codeblock">
                <code>
                    <pre>
<span class="comment">// evaluate an attribute at compile time</span>
<span class="preprocessor">version</span>(<span class="keyword">@arch</span> == x86-64)
{
    <span class="comment">// code here is compiled only when the @arch attribute equals x86-64</span>
}
<span class="preprocessor">else</span>
{
    <span class="comment">// version condition is not satisified</span>
}

<span class="comment">// because this is so common for debugging, there's a built-in</span>
<span class="comment">// shortcut for version(@debug >= x)</span>
<span class="preprocessor">debug</span>(5)
{
    <span class="comment">// code here is compiled only when the @debug attribute >= 5</span>
}</pre>
                </code>
            </div>
        </section>
        <footer id="contentinfo" class="body">
            yo me is footer
        </footer>
    </body>
</html>
